<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="num">
        <ul class="list"></ul>
    </div>
</body>
<!--<script>
    var ul = document.querySelector('.list');
    var arr = [3, 4, 7, 2, 3, 4, 5, 6];
    // ul.addEventListener("click",fn1)

    for (var i = 0; i < arr.length; i++) {
        // index = this.index
        var li = document.createElement('li');
        li.innerHTML = arr[i];
        li.setAttribute('count',i)//给每个li添加一个不同的属性
        ul.appendChild(li);
    }

    var liArr = ul.children;
    // console.log(liArr[2].innerText)

    for (var i = 0; i < liArr.length; i++) {
        liArr[i].onclick = function(e) {
            console.log(e.target)
            this.innerHTML--;
            arr[e.target.getAttribute('count')]=+this.innerHTML;//每个li的属性都不同
        };
    }

</script>-->

<script>
    var ul = document.querySelector('.list');
    var arr = [3, 4, 7, 2, 3, 4, 5, 6];
    // ul.addEventListener("click",fn1)

    for (var i = 0; i < arr.length; i++) {
        // index = this.index
        var li = document.createElement('li');
        li.innerHTML = arr[i];
        // li.setAttribute('count', i)
        ul.appendChild(li);
    }

    var liArr = ul.children;
    // console.log(liArr[2].innerText)

    for (var i = 0; i < liArr.length; i++) {
        liArr[i].onclick = (function () {//给点击事件一个自执行函数，for循环的时候执行这个函数，把i赋值给index保存起来，方便以后点击事件的时候获取。（这就是闭包导致内存泄漏的原因，保存的变量会非常多）
            var index = i;
            return function () {//自执行后其实是把return后的函数赋值给onclick点击事件，点击的时候执行
                this.innerHTML--;
                arr[index] = +this.innerHTML;//点击的时候通过之前保存的变量获取i的值
            console.log(arr);    
            };
        })(i)
    }
</script>

</html>